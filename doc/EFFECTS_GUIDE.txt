Effects Application Guide: Multiple Approaches
==============================================

How to apply visual effects to RenderSurfaces using different methods


PRIMITIVES OVERVIEW
===================

┌─────────────────────────────────────────────────────────────────┐
│                     CORE PRIMITIVES                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  RenderSurface                                                  │
│  ──────────────                                                 │
│  • 2D pixel matrix (color_map, shadow_map, char_map)            │
│  • Basic building block for all visuals                         │
│  • Can be input or output for effects                           │
│                                                                 │
│  Effect (Fade, Blur, Brighter, Darker, etc.)                    │
│  ─────────────────────────────────────────                      │
│  • Concrete effect type with parameters                         │
│  • Has run() method: processes input → output                   │
│  • Has validate() method: checks parameters                     │
│  • Has surface_expand: optional expansion requirements          │
│  • Example: Fade { alpha_start, alpha_end, duration }           │
│                                                                 │
│  RenderEffect                                                   │
│  ─────────────                                                  │
│  • Type-erased wrapper around any Effect                        │
│  • Enables polymorphism (different effects in same chain)       │
│  • Created via: effect.asEffect() or RenderEffect.init()        │
│  • Can be used in chains, pipelines, or standalone              │
│                                                                 │
│  RenderEffectContext                                            │
│  ────────────────────                                           │
│  • Bundles input_surface + output_surface                       │
│  • Tracks expansion_applied (for size changes)                  │
│  • Passed to effects for processing                             │
│                                                                 │
│  RenderEffectChain                                              │
│  ──────────────────                                             │
│  • Sequence of RenderEffects applied in order                   │
│  • Manages intermediate surfaces automatically                  │
│  • Accumulates expansion requirements                           │
│  • Example: Fade → Blur → Brighter                              │
│                                                                 │
│  RenderObject                                                   │
│  ─────────────                                                  │
│  • Wraps: input_surface + optional effect_chain                 │
│  • Unit of rendering in RenderPipeline                          │
│  • Contains RenderEffectContext internally                      │
│  • process() applies effects and returns output                 │
│                                                                 │
│  RenderEngine                                                   │
│  ─────────────                                                  │
│  • Composites multiple RenderSurfaces into one                  │
│  • Handles z-ordering, blending, transparency                   │
│  • Used by RenderPipeline and Screen                            │
│                                                                 │
│  RenderPipeline                                                 │
│  ───────────────                                                │
│  • Orchestrates multiple RenderObjects                          │
│  • Processes each object (applies their effect chains)          │
│  • Merges all outputs via RenderEngine                          │
│  • Optionally applies final post-processing chain               │
│  • Outputs to target surface (e.g., Screen.output_surface)      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘


═══════════════════════════════════════════════════════════════════
METHOD 1: DIRECT EFFECT APPLICATION (runOnSurfaces)
═══════════════════════════════════════════════════════════════════

Use Case: Apply a single effect manually, full control

┌─────────────────────────────────────────────────────────────────┐
│                   STEP 1: CREATE SURFACES                       │
└─────────────────────────────────────────────────────────────────┘

        ┌──────────────────────────────────────────────────────┐
        │  input_surface = RenderSurface.init(10, 10, ...)     │
        │  ┌────────────────────────────────────────────────┐  │
        │  │ 10×10 pixels, filled with gray (128,128,128)   │  │
        │  │ All pixels opaque (shadow_map = 1)             │  │
        │  └────────────────────────────────────────────────┘  │
        └────────────────────────┬─────────────────────────────┘
                                 │
                                 ▼
        ┌──────────────────────────────────────────────────────┐
        │  output_surface = RenderSurface.init(10, 10, ...)    │
        │  ┌────────────────────────────────────────────────┐  │
        │  │ 10×10 pixels, cleared to black (0,0,0)         │  │
        │  │ Ready to receive effect output                 │  │
        │  └────────────────────────────────────────────────┘  │
        └────────────────────────┬─────────────────────────────┘
                                 │
                                 ▼

┌─────────────────────────────────────────────────────────────────┐
│                 STEP 2: CREATE EFFECT INSTANCE                  │
└─────────────────────────────────────────────────────────────────┘

        ┌──────────────────────────────────────────────────────┐
        │  var fade = Effect.Fade {                            │
        │      .alpha_start = 1.0,    // Fully opaque          │
        │      .alpha_end = 0.0,      // Fully transparent     │
        │      .duration = 60,        // 60 frames             │
        │  };                                                  │
        │  ┌────────────────────────────────────────────────┐  │
        │  │ Fade Effect Parameters                         │  │
        │  │  • Interpolates alpha from start to end        │  │
        │  │  • At frame 0: alpha = 1.0 (full brightness)   │  │
        │  │  • At frame 30: alpha = 0.5 (half brightness)  │  │
        │  │  • At frame 60: alpha = 0.0 (invisible)        │  │
        │  └────────────────────────────────────────────────┘  │
        └────────────────────────┬─────────────────────────────┘
                                 │
                                 ▼

┌─────────────────────────────────────────────────────────────────┐
│              STEP 3: WRAP AS RENDEREFFECT                       │
└─────────────────────────────────────────────────────────────────┘

        ┌──────────────────────────────────────────────────────┐
        │  const fade_effect = fade.asEffect();                │
        │  ┌────────────────────────────────────────────────┐  │
        │  │ RenderEffect (type-erased wrapper)             │  │
        │  │  • instance: pointer to fade                   │  │
        │  │  • runFn: Fade.run (wrapped)                   │  │
        │  │  • validateFn: Fade.validate (wrapped)         │  │
        │  │  • surface_expand: null (Fade doesn't expand)  │  │
        │  └────────────────────────────────────────────────┘  │
        └────────────────────────┬─────────────────────────────┘
                                 │
                                 ▼

┌─────────────────────────────────────────────────────────────────┐
│                STEP 4: RUN EFFECT DIRECTLY                      │
└─────────────────────────────────────────────────────────────────┘

        ┌──────────────────────────────────────────────────────┐
        │  try fade_effect.runOnSurfaces(                      │
        │      input_surface,     // Source                    │
        │      output_surface,    // Destination               │
        │      30                 // Current frame             │
        │  );                                                  │
        │  ┌────────────────────────────────────────────────┐  │
        │  │ Processing:                                    │  │
        │  │                                                │  │
        │  │ 1. Validate parameters (duration > 0, etc.)    │  │
        │  │                                                │  │
        │  │ 2. Calculate alpha at frame 30:                │  │
        │  │    t = 30 / 60 = 0.5                           │  │
        │  │    alpha = 1.0 + (0.0 - 1.0) × 0.5 = 0.5       │  │
        │  │                                                │  │
        │  │ 3. For each pixel in input_surface:            │  │
        │  │    ┌────────────────────────────────────────┐  │  │
        │  │    │ Input:  RGB(128, 128, 128)             │  │  │
        │  │    │         ↓                              │  │  │
        │  │    │ Apply:  × 0.5 alpha                    │  │  │
        │  │    │         ↓                              │  │  │
        │  │    │ Output: RGB(64, 64, 64)                │  │  │
        │  │    └────────────────────────────────────────┘  │  │
        │  │                                                │  │
        │  │ 4. Write to output_surface                     │  │
        │  └────────────────────────────────────────────────┘  │
        └────────────────────────┬─────────────────────────────┘
                                 │
                                 ▼
        ┌──────────────────────────────────────────────────────┐
        │  Result: output_surface has faded pixels             │
        │  ┌────────────────────────────────────────────────┐  │
        │  │ All pixels: RGB(64, 64, 64) - half brightness  │  │
        │  └────────────────────────────────────────────────┘  │
        └──────────────────────────────────────────────────────┘


PROS & CONS:
────────────
✓ Simple and direct
✓ Full manual control
✓ No intermediate allocations
✗ Only one effect at a time
✗ Manual surface management
✗ No automatic expansion handling


CODE EXAMPLE:
─────────────

const movy = @import("movy");

var input = try movy.RenderSurface.init(
				allocator, 10, 10, .{.r=128, .g=128, .b=128});
defer input.deinit(allocator);
for (input.shadow_map) |*s| s.* = 1;

var output = try movy.RenderSurface.init(allocator, 10, 10, .{.r=0, .g=0, .b=0});
defer output.deinit(allocator);

var fade = movy.render.Effect.Fade {
    .alpha_start = 1.0,
    .alpha_end = 0.0,
    .duration = 60,
};

const fade_effect = fade.asEffect();
try fade_effect.runOnSurfaces(input, output, 30);

// output now contains faded image


═══════════════════════════════════════════════════════════════════
METHOD 2: EFFECT CHAIN (Multiple Effects in Sequence)
═══════════════════════════════════════════════════════════════════

Use Case: Apply multiple effects in order, automatic management

┌─────────────────────────────────────────────────────────────────┐
│                   STEP 1: CREATE EFFECTS                        │
└─────────────────────────────────────────────────────────────────┘

        ┌──────────────────────────────────────────────────────┐
        │  var fade = Effect.Fade {                            │
        │      .alpha_start = 0.0,                             │
        │      .alpha_end = 1.0,                               │
        │      .duration = 60,                                 │
        │  };                                                  │
        │  const fade_effect = fade.asEffect();                │
        └────────────────────────┬─────────────────────────────┘
                                 │
                                 ▼
        ┌──────────────────────────────────────────────────────┐
        │  var blur = Effect.Blur {                            │
        │      .radius = 10,                                   │
        │  };                                                  │
        │  const blur_effect = blur.asEffect();                │
        └────────────────────────┬─────────────────────────────┘
                                 │
                                 ▼

┌─────────────────────────────────────────────────────────────────┐
│              STEP 2: CREATE AND BUILD CHAIN                     │
└─────────────────────────────────────────────────────────────────┘

        ┌──────────────────────────────────────────────────────┐
        │  var chain = try RenderEffectChain.init(allocator);  │
        │  defer chain.deinit(allocator);                      │
        │                                                      │
        │  try chain.chainEffect(blur_effect);                 │
        │  try chain.chainEffect(fade_effect);                 │
        │  ┌────────────────────────────────────────────────┐  │
        │  │ RenderEffectChain                              │  │
        │  │                                                │  │
        │  │ effect_links: [EffectLink, EffectLink]         │  │
        │  │  ┌──────────────────────────────────────────┐  │  │
        │  │  │ [0]: Blur effect                         │  │  │
        │  │  │      out_surface: null (created on run)  │  │  │
        │  │  ├──────────────────────────────────────────┤  │  │
        │  │  │ [1]: Fade effect                         │  │  │
        │  │  │      out_surface: null (uses ctx output) │  │  │
        │  │  └──────────────────────────────────────────┘  │  │
        │  │                                                │  │
        │  │ total_border_expand: {x: 0, y: 0}              │  │
        │  │   (accumulated from all effects)               │  │
        │  └────────────────────────────────────────────────┘  │
        └────────────────────────┬─────────────────────────────┘
                                 │
                                 ▼

┌─────────────────────────────────────────────────────────────────┐
│            STEP 3: CREATE EFFECT CONTEXT                        │
└─────────────────────────────────────────────────────────────────┘

        ┌──────────────────────────────────────────────────────┐
        │  var fx_ctx = RenderEffectContext {                  │
        │      .input_surface = input_surface,                 │
        │      .output_surface = output_surface,               │
        │  };                                                  │
        │  ┌────────────────────────────────────────────────┐  │
        │  │ RenderEffectContext                            │  │
        │  │  • input_surface → 10×10 gray                  │  │
        │  │  • output_surface → 10×10 black (target)       │  │
        │  │  • expansion_applied: null (not yet)           │  │
        │  └────────────────────────────────────────────────┘  │
        └────────────────────────┬─────────────────────────────┘
                                 │
                                 ▼

┌─────────────────────────────────────────────────────────────────┐
│                  STEP 4: RUN THE CHAIN                          │
└─────────────────────────────────────────────────────────────────┘

        ┌──────────────────────────────────────────────────────┐
        │  try chain.run(allocator, &fx_ctx, 30);              │
        │  ┌────────────────────────────────────────────────┐  │
        │  │ Chain Execution:                               │  │
        │  │                                                │  │
        │  │ PHASE 1: dryResize()                           │  │
        │  │ ──────────────────────                         │  │
        │  │  • Calculate required sizes                    │  │
        │  │  • Allocate intermediate surface for Blur      │  │
        │  │    (blur.out_surface = 10×10)                  │  │
        │  │  • Resize output_surface if needed             │  │
        │  │                                                │  │
        │  │ PHASE 2: Sequential Effect Execution           │  │
        │  │ ───────────────────────────────────            │  │
        │  │                                                │  │
        │  │  Effect 1: Blur                                │  │
        │  │  ┌──────────────────────────────────────────┐  │  │
        │  │  │ Input:  input_surface (10×10 gray)       │  │  │
        │  │  │         RGB(128, 128, 128)               │  │  │
        │  │  │         ↓                                │  │  │
        │  │  │ Blur:   radius = 10                      │  │  │
        │  │  │         R = 128 + 10 = 138               │  │  │
        │  │  │         G = 128 + 10 = 138               │  │  │
        │  │  │         B = 128 + 10 = 138               │  │  │
        │  │  │         ↓                                │  │  │
        │  │  │ Output: intermediate_surface             │  │  │
        │  │  │         RGB(138, 138, 138)               │  │  │
        │  │  └──────────────────────────────────────────┘  │  │
        │  │                 ↓                              │  │
        │  │  Effect 2: Fade                                │  │
        │  │  ┌──────────────────────────────────────────┐  │  │
        │  │  │ Input:  intermediate_surface             │  │  │
        │  │  │         RGB(138, 138, 138)               │  │  │
        │  │  │         ↓                                │  │  │
        │  │  │ Fade:   frame 30, duration 60            │  │  │
        │  │  │         alpha = 0.5                      │  │  │
        │  │  │         R = 138 × 0.5 = 69               │  │  │
        │  │  │         G = 138 × 0.5 = 69               │  │  │
        │  │  │         B = 138 × 0.5 = 69               │  │  │
        │  │  │         ↓                                │  │  │
        │  │  │ Output: output_surface                   │  │  │
        │  │  │         RGB(69, 69, 69)                  │  │  │
        │  │  └──────────────────────────────────────────┘  │  │
        │  │                                                │  │
        │  └────────────────────────────────────────────────┘  │
        └────────────────────────┬─────────────────────────────┘
                                 │
                                 ▼
        ┌──────────────────────────────────────────────────────┐
        │  Result: output_surface has both effects applied     │
        │  ┌────────────────────────────────────────────────┐  │
        │  │ RGB(69, 69, 69) - blurred then faded           │  │
        │  └────────────────────────────────────────────────┘  │
        └──────────────────────────────────────────────────────┘


CHAIN DATA FLOW:
────────────────

  input_surface          intermediate         output_surface
  ┌──────────┐           ┌──────────┐          ┌──────────┐
  │ Original │  Effect1  │ After    │ Effect2  │  Final   │
  │  Image   │  ──────>  │ Effect 1 │ ──────>  │  Result  │
  │ 128,128  │   Blur    │ 138,138  │  Fade    │  69,69   │
  └──────────┘           └──────────┘          └──────────┘
                         (auto-managed)


PROS & CONS:
────────────
✓ Multiple effects in sequence
✓ Automatic intermediate surface management
✓ Automatic expansion handling
✓ Reusable chains
✗ More complex than single effect
✓ Effects processed in order added


CODE EXAMPLE:
─────────────

const movy = @import("movy");

var input = try movy.RenderSurface.init(allocator, 10, 10, .{.r=128, .g=128, .b=128});
defer input.deinit(allocator);

var output = try movy.RenderSurface.init(allocator, 10, 10, .{.r=0, .g=0, .b=0});
defer output.deinit(allocator);

var fade = movy.render.Effect.Fade { .alpha_start = 0.0, .alpha_end = 1.0, .duration = 60 };
var blur = movy.render.Effect.Blur { .radius = 10 };

var chain = try movy.render.RenderEffectChain.init(allocator);
defer chain.deinit(allocator);

try chain.chainEffect(blur.asEffect());
try chain.chainEffect(fade.asEffect());

var fx_ctx = movy.render.Effect.RenderEffectContext {
    .input_surface = input,
    .output_surface = output,
};

try chain.run(allocator, &fx_ctx, 30);
// output has blur + fade applied


═══════════════════════════════════════════════════════════════════
METHOD 3: RENDER PIPELINE (Complete Rendering System)
═══════════════════════════════════════════════════════════════════

Use Case: Multiple objects with effects, composited together

┌─────────────────────────────────────────────────────────────────┐
│                   ARCHITECTURE OVERVIEW                         │
└─────────────────────────────────────────────────────────────────┘

  RenderObject 1        RenderObject 2        RenderObject N
  ┌────────────┐        ┌────────────┐        ┌────────────┐
  │ Surface A  │        │ Surface B  │        │ Surface C  │
  │    +       │        │    +       │        │    +       │
  │ EffectChain│        │ EffectChain│        │ EffectChain│
  └─────┬──────┘        └─────┬──────┘        └─────┬──────┘
        │                     │                     │
        │ .process()          │ .process()          │ .process()
        ▼                     ▼                     ▼
   ┌──────────┐         ┌──────────┐         ┌──────────┐
   │ Output A │         │ Output B │         │ Output C │
   └─────┬────┘         └─────┬────┘         └─────┬────┘
         │                    │                    │
         └────────────────────┼────────────────────┘
                              │
                              ▼
                  ┌───────────────────────┐
                  │   RenderEngine.render │
                  │   (composite/merge)   │
                  └───────────┬───────────┘
                              │
                              ▼
                       ┌─────────────┐
                       │   Merged    │
                       │   Result    │
                       └──────┬──────┘
                              │
               Optional Final Effect Chain
                              │
                              ▼
                    ┌──────────────────┐
                    │ output_surface   │
                    │ (Screen, etc.)   │
                    └──────────────────┘


┌─────────────────────────────────────────────────────────────────┐
│                STEP 1: CREATE SPRITE/SURFACES                   │
└─────────────────────────────────────────────────────────────────┘

        ┌──────────────────────────────────────────────────────┐
        │  var sprite = Sprite.initFromPng(                    │
        │      allocator,                                      │
        │      "logo.png",                                     │
        │      "my_sprite"                                     │
        │  );                                                  │
        │  defer sprite.deinit(allocator);                     │
        │                                                      │
        │  const input_surface = sprite.getCurrentFrameSurface();│
        │  ┌────────────────────────────────────────────────┐  │
        │  │ Surface loaded from PNG                        │  │
        │  │  • Contains sprite pixel data                  │  │
        │  │  • Will be input to RenderObject               │  │
        │  └────────────────────────────────────────────────┘  │
        └────────────────────────┬─────────────────────────────┘
                                 │
                                 ▼

┌─────────────────────────────────────────────────────────────────┐
│             STEP 2: CREATE EFFECT CHAIN                         │
└─────────────────────────────────────────────────────────────────┘

        ┌──────────────────────────────────────────────────────┐
        │  var fade = Effect.Fade {                            │
        │      .alpha_start = 0.0,                             │
        │      .alpha_end = 1.0,                               │
        │      .duration = 60,                                 │
        │  };                                                  │
        │  var blur = Effect.Blur { .radius = 10 };            │
        │                                                      │
        │  var chain = try RenderEffectChain.init(allocator);  │
        │  defer chain.deinit(allocator);                      │
        │                                                      │
        │  try chain.chainEffect(fade.asEffect());             │
        │  try chain.chainEffect(blur.asEffect());             │
        └────────────────────────┬─────────────────────────────┘
                                 │
                                 ▼

┌─────────────────────────────────────────────────────────────────┐
│          STEP 3: CREATE RENDER PIPELINE & OBJECT                │
└─────────────────────────────────────────────────────────────────┘

        ┌──────────────────────────────────────────────────────┐
        │  var pipeline = try RenderPipeline.init(             │
        │      allocator,                                      │
        │      screen.output_surface  // Target                │
        │  );                                                  │
        │  defer pipeline.deinit(allocator);                   │
        │  ┌────────────────────────────────────────────────┐  │
        │  │ RenderPipeline                                 │  │
        │  │  • render_objects: []                          │  │
        │  │  • effect_chain: null (optional final chain)   │  │
        │  │  • output_surface: screen.output_surface       │  │
        │  │  • result_surface: intermediate (auto-created) │  │
        │  └────────────────────────────────────────────────┘  │
        └────────────────────────┬─────────────────────────────┘
                                 │
                                 ▼
        ┌──────────────────────────────────────────────────────┐
        │  const render_obj = try RenderObject.init(           │
        │      allocator,                                      │
        │      input_surface,    // Sprite surface             │
        │      &chain            // Effect chain               │
        │  );                                                  │
        │  ┌────────────────────────────────────────────────┐  │
        │  │ RenderObject                                   │  │
        │  │  • effect_ctx:                                 │  │
        │  │    - input_surface: sprite surface             │  │
        │  │    - output_surface: auto-created              │  │
        │  │  • effect_chain: pointer to chain              │  │
        │  └────────────────────────────────────────────────┘  │
        └────────────────────────┬─────────────────────────────┘
                                 │
                                 ▼
        ┌──────────────────────────────────────────────────────┐
        │  try pipeline.addObject(render_obj);                 │
        │  ┌────────────────────────────────────────────────┐  │
        │  │ RenderPipeline.render_objects                  │  │
        │  │  ┌──────────────────────────────────────────┐  │  │
        │  │  │ [0]: RenderObject (sprite + chain)       │  │  │
        │  │  └──────────────────────────────────────────┘  │  │
        │  │                                                │  │
        │  │ Can add more objects:                          │  │
        │  │  • Each with own surface                       │  │
        │  │  • Each with own effect chain (or null)        │  │
        │  │  • All will be composited together             │  │
        │  └────────────────────────────────────────────────┘  │
        └────────────────────────┬─────────────────────────────┘
                                 │
                                 ▼

┌─────────────────────────────────────────────────────────────────┐
│                 STEP 4: RUN THE PIPELINE                        │
└─────────────────────────────────────────────────────────────────┘

        ┌──────────────────────────────────────────────────────┐
        │  try pipeline.run(allocator, 30);  // frame = 30     │
        │  ┌────────────────────────────────────────────────┐  │
        │  │ Pipeline Execution:                            │  │
        │  │                                                │  │
        │  │ PHASE 1: Process RenderObjects                 │  │
        │  │ ────────────────────────────                   │  │
        │  │                                                │  │
        │  │  For each RenderObject:                        │  │
        │  │   ┌──────────────────────────────────────────┐ │  │
        │  │   │ Object 1: process()                      │ │  │
        │  │   │                                          │ │  │
        │  │   │  • Run effect_chain if present:          │ │  │
        │  │   │    Input: sprite surface                 │ │  │
        │  │   │      ↓                                   │ │  │
        │  │   │    Fade: alpha = 0.5 (frame 30)          │ │  │
        │  │   │      ↓                                   │ │  │
        │  │   │    Blur: radius = 10                     │ │  │
        │  │   │      ↓                                   │ │  │
        │  │   │    Output: processed surface             │ │  │
        │  │   │                                          │ │  │
        │  │   │  • Return output_surface                 │ │  │
        │  │   └──────────────────────────────────────────┘ │  │
        │  │                                                │  │
        │  │  Collect all outputs: [output1, output2, ...]  │  │
        │  │                                                │  │
        │  │ PHASE 2: Composite Outputs                     │  │
        │  │ ────────────────────────                       │  │
        │  │                                                │  │
        │  │   ┌──────────────────────────────────────────┐ │  │
        │  │   │ RenderEngine.render(                     │ │  │
        │  │   │     [output1, output2, ...],             │ │  │
        │  │   │     result_surface                       │ │  │
        │  │   │ )                                        │ │  │
        │  │   │                                          │ │  │
        │  │   │  • Merge all outputs into one            │ │  │
        │  │   │  • Apply z-ordering                      │ │  │
        │  │   │  • Handle transparency                   │ │  │
        │  │   │  • Clip to bounds                        │ │  │
        │  │   └──────────────────────────────────────────┘ │  │
        │  │                                                │  │
        │  │ PHASE 3: Optional Final Effect Chain           │  │
        │  │ ──────────────────────────────────             │  │
        │  │                                                │  │
        │  │  If pipeline.effect_chain is set:              │  │
        │  │   ┌──────────────────────────────────────────┐ │  │
        │  │   │ Input: result_surface                    │ │  │
        │  │   │   ↓                                      │ │  │
        │  │   │ Apply final chain (e.g., screen fade)    │ │  │
        │  │   │   ↓                                      │ │  │
        │  │   │ Output: output_surface                   │ │  │
        │  │   └──────────────────────────────────────────┘ │  │
        │  │                                                │  │
        │  │  Else (no final chain):                        │  │
        │  │   ┌──────────────────────────────────────────┐ │  │
        │  │   │ Copy result_surface → output_surface     │ │  │
        │  │   └──────────────────────────────────────────┘ │  │
        │  │                                                │  │
        │  └────────────────────────────────────────────────┘  │
        └────────────────────────┬─────────────────────────────┘
                                 │
                                 ▼
        ┌──────────────────────────────────────────────────────┐
        │  Result: screen.output_surface ready to display      │
        │  ┌────────────────────────────────────────────────┐  │
        │  │ All objects composited with effects applied    │  │
        │  └────────────────────────────────────────────────┘  │
        └──────────────────────────────────────────────────────┘


PIPELINE DATA FLOW (Multiple Objects):
───────────────────────────────────────

  Object 1              Object 2              Object 3
  ┌────────┐            ┌────────┐            ┌────────┐
  │Surface │            │Surface │            │Surface │
  │   +    │            │   +    │            │   +    │
  │ Chain  │            │ Chain  │            │  null  │
  └───┬────┘            └───┬────┘            └───┬────┘
      │                     │                     │
      │ .process()          │ .process()          │ (no effects)
      ▼                     ▼                     ▼
  ┌────────┐            ┌────────┐            ┌────────┐
  │Output1 │            │Output2 │            │Output3 │
  └───┬────┘            └───┬────┘            └───┬────┘
      │                     │                     │
      └─────────────────────┼─────────────────────┘
                            │
                            ▼
                ┌───────────────────────┐
                │   RenderEngine.render │
                │     (composite)       │
                └───────────┬───────────┘
                            │
                            ▼
                     ┌─────────────┐
                     │   Merged    │
                     │   Result    │
                     └──────┬──────┘
                            │
                 Optional Final Chain
                            │
                            ▼
                  ┌──────────────────┐
                  │ output_surface   │
                  └──────────────────┘


PROS & CONS:
────────────
✓ Handles multiple objects with different effects
✓ Automatic composition via RenderEngine
✓ Optional final post-processing chain
✓ Clean separation of concerns
✓ Perfect for complex scenes
✓ Automatic z-ordering and blending
✗ More complex setup
✗ Overkill for single objects


CODE EXAMPLE:
─────────────

const movy = @import("movy");

var screen = try movy.Screen.init(allocator, 120, 40);
defer screen.deinit(allocator);

var sprite = try movy.Sprite.initFromPng(allocator, "logo.png", "logo");
defer sprite.deinit(allocator);

const input_surface = try sprite.getCurrentFrameSurface();

var fade = movy.render.Effect.Fade { .alpha_start = 0.0, .alpha_end = 1.0, .duration = 60 };
var blur = movy.render.Effect.Blur { .radius = 10 };

var chain = try movy.render.RenderEffectChain.init(allocator);
defer chain.deinit(allocator);
try chain.chainEffect(fade.asEffect());
try chain.chainEffect(blur.asEffect());

var pipeline = try movy.render.RenderPipeline.init(allocator, screen.output_surface);
defer pipeline.deinit(allocator);

const render_obj = try movy.render.RenderObject.init(allocator, input_surface, &chain);
try pipeline.addObject(render_obj);

// Add more objects if needed:
// try pipeline.addObject(render_obj2);
// try pipeline.addObject(render_obj3);

try pipeline.run(allocator, 30);  // Process at frame 30

// screen.output_surface now has all objects composited with effects
try screen.output();


═══════════════════════════════════════════════════════════════════
COMPARISON SUMMARY
═══════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  Method 1: runOnSurfaces()                                      │
│  ──────────────────────────                                     │
│    Use When: Single effect, manual control                      │
│    Complexity: ★☆☆                                              │
│    Flexibility: ★☆☆                                             │
│    Power: ★☆☆                                                   │
│                                                                 │
│  Method 2: RenderEffectChain                                    │
│  ────────────────────────────                                   │
│    Use When: Multiple effects on single surface                 │
│    Complexity: ★★☆                                              │
│    Flexibility: ★★☆                                             │
│    Power: ★★☆                                                   │
│                                                                 │
│  Method 3: RenderPipeline                                       │
│  ─────────────────────────                                      │
│    Use When: Multiple objects with effects, complex scenes      │
│    Complexity: ★★★                                              │
│    Flexibility: ★★★                                             │
│    Power: ★★★                                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘


WHEN TO USE EACH METHOD:
─────────────────────────

runOnSurfaces():
  • Testing single effects
  • Simple, one-off transformations
  • Full manual control needed
  • Learning/experimentation

RenderEffectChain:
  • Post-processing single image
  • Sequential effect application
  • Automatic intermediate management
  • Reusable effect sequences

RenderPipeline:
  • Game rendering (multiple sprites)
  • UI composition (windows, widgets)
  • Complex scenes with layers
  • Each object needs different effects
  • Screen-wide post-processing


AVAILABLE EFFECTS:
──────────────────

  • Fade       - Alpha blending over time
  • Blur       - Blur effect with radius
  • Brighter   - Increase brightness
  • Darker     - Decrease brightness
  • OutlineRotator - Rotating outline effect
  • Dummy      - No-op (for testing)


TIPS:
─────

• Always use .asEffect() to wrap concrete effects
• Chain order matters: effects applied sequentially
• RenderPipeline merges with z-ordering (surface.z)
• Use final chain for screen-wide effects (vignette, etc.)
• Effects can declare surface_expand for glow/shake
• RenderEffectContext handles expansion automatically
