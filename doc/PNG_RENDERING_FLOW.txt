Basic Primitive Rendering: Render a PNG File to Screen
========================================================

Use Case: Load a PNG and display it in the terminal (simplest approach)


STEP 1: LOAD PNG FILE
======================
        ┌──────────────────────────────────────────────────────────┐
        │                    PNG FILE                              │
        │  ┌────────────────────────────────────────────────────┐  │
        │  │  "image.png"                                       │  │
        │  │  ┌──────────────────────────────────────────────┐  │  │
        │  │  │ RGBA32 pixel data                            │  │  │
        │  │  │ • Red channel   (0-255)                      │  │  │
        │  │  │ • Green channel (0-255)                      │  │  │
        │  │  │ • Blue channel  (0-255)                      │  │  │
        │  │  │ • Alpha channel (0-255) transparency         │  │  │
        │  │  └──────────────────────────────────────────────┘  │  │
        │  └────────────────────────────────────────────────────┘  │
        └────────────────────────────┬─────────────────────────────┘
                                     │
                                     │ lodepng_decode32_file()
                                     │ (C library: src/core/lodepng/)
                                     ▼
        ┌──────────────────────────────────────────────────────────┐
        │            RenderSurface.createFromPng()                 │
        │  ┌────────────────────────────────────────────────────┐  │
        │  │ 1. Decode PNG → RGBA buffer in memory              │  │
        │  │ 2. Extract width × height dimensions               │  │
        │  │ 3. Allocate RenderSurface(width, height)           │  │
        │  │ 4. For each pixel:                                 │  │
        │  │    • Copy RGB → color_map[i]                       │  │
        │  │    • Set shadow_map[i] = (alpha > 0) ? 1 : 0       │  │
        │  │    • Clear char_map[i] = 0                         │  │
        │  └────────────────────────────────────────────────────┘  │
        └────────────────────────────┬─────────────────────────────┘
                                     │
                                     ▼


STEP 2: RENDERSURFACE CREATED
==============================
        ┌──────────────────────────────────────────────────────────┐
        │                   RenderSurface                          │
        │  ┌────────────────────────────────────────────────────┐  │
        │  │ Data members:                                      │  │
        │  │                                                    │  │
        │  │  color_map: []Rgb                                  │  │
        │  │  ┌─────────────────────────────────────────────┐   │  │
        │  │  │ [0]: {r: 255, g: 100, b: 50}                │   │  │
        │  │  │ [1]: {r: 120, g: 200, b: 80}                │   │  │
        │  │  │ [2]: {r:  50, g:  75, b: 150}               │   │  │
        │  │  │ ...                                         │   │  │
        │  │  │ [w×h-1]: {r: 0, g: 0, b: 0}                 │   │  │
        │  │  └─────────────────────────────────────────────┘   │  │
        │  │                                                    │  │
        │  │  shadow_map: []u8                                  │  │
        │  │  ┌─────────────────────────────────────────────┐   │  │
        │  │  │ [0]: 1   (opaque)                           │   │  │
        │  │  │ [1]: 1   (opaque)                           │   │  │
        │  │  │ [2]: 0   (transparent, from alpha=0)        │   │  │
        │  │  │ ...                                         │   │  │
        │  │  │ [w×h-1]: 1                                  │   │  │
        │  │  └─────────────────────────────────────────────┘   │  │
        │  │                                                    │  │
        │  │  char_map: []u21                                   │  │
        │  │  ┌─────────────────────────────────────────────┐   │  │
        │  │  │ All zeros (no text overlay)                 │   │  │
        │  │  └─────────────────────────────────────────────┘   │  │
        │  │                                                    │  │
        │  │  Dimensions & Position:                            │  │
        │  │  • w: width in pixels                              │  │
        │  │  • h: height in pixels (rows)                      │  │
        │  │  • x: 0 (default position)                         │  │
        │  │  • y: 0 (default position)                         │  │
        │  │  • z: 0 (default z-order)                          │  │
        │  └────────────────────────────────────────────────────┘  │
        └────────────────────────────┬─────────────────────────────┘
                                     │
                                     │ Optional: Set position
                                     │ surface.x = 10
                                     │ surface.y = 5
                                     │ surface.z = 1
                                     ▼


STEP 3: INITIALIZE SCREEN
==========================
        ┌──────────────────────────────────────────────────────────┐
        │         Screen.init(allocator, width, height)            │
        │  ┌────────────────────────────────────────────────────┐  │
        │  │ Creates:                                           │  │
        │  │  • output_surface: RenderSurface(w, h*2)           │  │
        │  │  • sprites: ArrayList (empty)                      │  │
        │  │  • output_surfaces: ArrayList (empty)              │  │
        │  │                                                    │  │
        │  │ Initializes terminal:                              │  │
        │  │  • Hides cursor                                    │  │
        │  │  • Clears screen with bg_color                     │  │
        │  └────────────────────────────────────────────────────┘  │
        └────────────────────────────┬─────────────────────────────┘
                                     │
                                     ▼
        ┌──────────────────────────────────────────────────────────┐
        │                       Screen                             │
        │  ┌────────────────────────────────────────────────────┐  │
        │  │ w: 80            (screen width in chars)           │  │
        │  │ h: 50×2 = 100    (height in pixel rows)            │  │
        │  │ bg_color: {r: 0x20, g: 0x20, b: 0x20}              │  │
        │  │                                                    │  │
        │  │ output_surface: *RenderSurface                     │  │
        │  │ ┌──────────────────────────────────────────────┐   │  │
        │  │ │ Initially filled with bg_color               │   │  │
        │  │ │ All pixels opaque                            │   │  │
        │  │ └──────────────────────────────────────────────┘   │  │
        │  │                                                    │  │
        │  │ sprites: []          (empty)                       │  │
        │  │ output_surfaces: []  (empty)                       │  │
        │  └────────────────────────────────────────────────────┘  │
        └────────────────────────────┬─────────────────────────────┘
                                     │
                                     ▼


STEP 4: ADD RENDERSURFACE TO SCREEN
====================================
        ┌──────────────────────────────────────────────────────────┐
        │          screen.addRenderSurface(surface)                │
        │  ┌────────────────────────────────────────────────────┐  │
        │  │ Appends the surface pointer to:                    │  │
        │  │   screen.output_surfaces.append(surface)           │  │
        │  └────────────────────────────────────────────────────┘  │
        └────────────────────────────┬─────────────────────────────┘
                                     │
                                     ▼
        ┌──────────────────────────────────────────────────────────┐
        │                  Screen (updated)                        │
        │  ┌────────────────────────────────────────────────────┐  │
        │  │ output_surfaces: [*RenderSurface]                  │  │
        │  │  ┌──────────────────────────────────────────────┐  │  │
        │  │  │ [0]: pointer to our PNG-loaded surface       │  │  │
        │  │  │      (with x, y, z coordinates)              │  │  │
        │  │  └──────────────────────────────────────────────┘  │  │
        │  └────────────────────────────────────────────────────┘  │
        └────────────────────────────┬─────────────────────────────┘
                                     │
                                     ▼


STEP 5: RENDER (COMPOSITE SURFACES)
====================================
        ┌──────────────────────────────────────────────────────────┐
        │                   screen.render()                        │
        │  ┌────────────────────────────────────────────────────┐  │
        │  │ 1. Clear output_surface based on screen_mode:      │  │
        │  │    • transparent: clearTransparent()               │  │
        │  │    • bgcolor: clearColored(bg_color)               │  │
        │  │                                                    │  │
        │  │ 2. Call RenderEngine.render():                     │  │
        │  │    ┌────────────────────────────────────────────┐  │  │
        │  │    │ RenderEngine.render(                       │  │  │
        │  │    │   surfaces_in: output_surfaces.items,      │  │  │
        │  │    │   out_surface: screen.output_surface       │  │  │
        │  │    │ )                                          │  │  │
        │  │    └────────────────────────────────────────────┘  │  │
        │  └────────────────────────────────────────────────────┘  │
        └────────────────────────────┬─────────────────────────────┘
                                     │
                                     ▼
        ┌──────────────────────────────────────────────────────────┐
        │               RenderEngine.render()                      │
        │  ┌────────────────────────────────────────────────────┐  │
        │  │ For each surface in surfaces_in:                   │  │
        │  │                                                    │  │
        │  │ 1. Calculate clipping boundaries:                  │  │
        │  │    • Handle negative x, y (off-screen)             │  │
        │  │    • Clip to output surface bounds                 │  │
        │  │                                                    │  │
        │  │ 2. For each pixel (y_start..y_end, x_start..x_end) │  │
        │  │    • Check shadow_map[idx] != 0 (is opaque?)       │  │
        │  │    • If opaque and not yet drawn:                  │  │
        │  │      - Copy color_map[in] → color_map[out]         │  │
        │  │      - Set shadow_map[out] = 1                     │  │
        │  │      - Copy char_map[in] → char_map[out]           │  │
        │  │                                                    │  │
        │  │ Result: All surfaces merged into output_surface    │  │
        │  │         with proper z-ordering and transparency    │  │
        │  └────────────────────────────────────────────────────┘  │
        └────────────────────────────┬─────────────────────────────┘
                                     │
                                     ▼
        ┌──────────────────────────────────────────────────────────┐
        │           Screen.output_surface (composited)             │
        │  ┌────────────────────────────────────────────────────┐  │
        │  │ Contains merged result of all added surfaces       │  │
        │  │ • Background pixels from screen bg_color           │  │
        │  │ • PNG pixels overlaid at (x, y) position           │  │
        │  │ • Transparent PNG pixels don't overwrite           │  │
        │  └────────────────────────────────────────────────────┘  │
        └────────────────────────────┬─────────────────────────────┘
                                     │
                                     ▼


STEP 6: OUTPUT TO TERMINAL
===========================
        ┌──────────────────────────────────────────────────────────┐
        │                   screen.output()                        │
        │  ┌────────────────────────────────────────────────────┐  │
        │  │ 1. Position cursor:                                │  │
        │  │    • cursorHome()                                  │  │
        │  │    • cursorRight(screen.x) if x > 0                │  │
        │  │    • cursorDown(screen.y / 2) if y > 0             │  │
        │  │                                                    │  │
        │  │ 2. Convert to ANSI:                                │  │
        │  │    rendered_ansi = output_surface.toAnsi()         │  │
        │  │                                                    │  │
        │  │ 3. Write to stdout:                                │  │
        │  │    stdout.writeAll(rendered_ansi)                  │  │
        │  └────────────────────────────────────────────────────┘  │
        └────────────────────────────┬─────────────────────────────┘
                                     │
                                     ▼
        ┌──────────────────────────────────────────────────────────┐
        │            RenderSurface.toAnsi()                        │
        │  ┌────────────────────────────────────────────────────┐  │
        │  │ Half-block rendering (processes 2 rows at a time): │  │
        │  │                                                    │  │
        │  │ For y = 0, 2, 4, ... (step by 2):                  │  │
        │  │   For each x:                                      │  │
        │  │     idx_upper = x + y * w                          │  │
        │  │     idx_lower = x + (y+1) * w                      │  │
        │  │                                                    │  │
        │  │     upper_pixel = color_map[idx_upper]             │  │
        │  │     lower_pixel = color_map[idx_lower]             │  │
        │  │     upper_opaque = shadow_map[idx_upper] != 0      │  │
        │  │     lower_opaque = shadow_map[idx_lower] != 0      │  │
        │  │                                                    │  │
        │  │     ┌─────────────────────────────────────────┐    │  │
        │  │     │ Determine block character:              │    │  │
        │  │     │  • Both opaque:   '▀' (upper half)      │    │  │
        │  │     │    FG=upper, BG=lower                   │    │  │
        │  │     │  • Upper only:    '▀' (upper half)      │    │  │
        │  │     │    FG=upper, BG=transparent             │    │  │
        │  │     │  • Lower only:    '▄' (lower half)      │    │  │
        │  │     │    FG=lower, BG=transparent             │    │  │
        │  │     │  • Neither:       ' ' (space)           │    │  │
        │  │     └─────────────────────────────────────────┘    │  │
        │  │                                                    │  │
        │  │     Generate ANSI sequence:                        │  │
        │  │     "\x1b[38;2;{r};{g};{b}m"  (foreground color)   │  │
        │  │     "\x1b[48;2;{r};{g};{b}m"  (background color)   │  │
        │  │     "{block_char}"             (▀ or ▄ or ' ')     │  │
        │  │                                                    │  │
        │  │   Add line terminator: "\x1b[0m\n"                 │  │
        │  │                                                    │  │
        │  │ Result: Complete ANSI string with RGB codes        │  │
        │  └────────────────────────────────────────────────────┘  │
        └────────────────────────────┬─────────────────────────────┘
                                     │
                                     ▼
        ┌──────────────────────────────────────────────────────────┐
        │                  TERMINAL OUTPUT                         │
        │  ┌────────────────────────────────────────────────────┐  │
        │  │ ANSI escape sequences displayed as:                │  │
        │  │                                                    │  │
        │  │  ████████████                                      │  │
        │  │  ██        ██    ← PNG image rendered              │  │
        │  │  ██  IMG   ██      with half-blocks                │  │
        │  │  ██        ██      2× vertical resolution          │  │
        │  │  ████████████                                      │  │
        │  │                                                    │  │
        │  │ Each terminal character represents 2 pixels:       │  │
        │  │  • Top pixel: foreground color                     │  │
        │  │  • Bottom pixel: background color                  │  │
        │  │  • Character: ▀ (upper), ▄ (lower), or ' '         │  │
        │  └────────────────────────────────────────────────────┘  │
        └──────────────────────────────────────────────────────────┘


═══════════════════════════════════════════════════════════════════
COMPLETE CODE EXAMPLE
═══════════════════════════════════════════════════════════════════

const std = @import("std");
const movy = @import("movy");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // STEP 1: Load PNG file
    const surface = try movy.RenderSurface.createFromPng(
        allocator,
        "image.png"
    );
    defer surface.deinit(allocator);

    // STEP 2: Set position (optional)
    surface.x = 10;
    surface.y = 5;
    surface.z = 0;

    // STEP 3: Initialize screen
    var screen = try movy.Screen.init(allocator, 80, 50);
    defer screen.deinit(allocator);

    // STEP 4: Add surface to screen
    try screen.addRenderSurface(surface);

    // STEP 5: Render (composite all surfaces)
    screen.render();

    // STEP 6: Output to terminal
    try screen.output();
}

═══════════════════════════════════════════════════════════════════


KEY CONCEPTS:
=============

RenderSurface.createFromPng():
    • Decodes PNG using lodepng C library
    • Extracts RGBA data into color_map and shadow_map
    • Alpha > 0 → opaque (shadow_map=1), else transparent (shadow_map=0)

Screen:
    • Container for multiple surfaces/sprites
    • Has its own output_surface for final composition
    • Maintains list of surfaces to render

screen.addRenderSurface():
    • Registers a surface for rendering
    • Surfaces rendered in order added (first-to-last)

screen.render():
    • Clears output_surface
    • Calls RenderEngine.render() to merge all surfaces
    • Respects x, y positioning and z-ordering
    • Handles transparency via shadow_map

RenderEngine.render():
    • Merges multiple surfaces into one
    • Clips surfaces to output bounds
    • Only draws opaque pixels (shadow_map != 0)
    • First-opaque-wins (no overdraw of already-set pixels)

screen.output():
    • Converts output_surface to ANSI via toAnsi()
    • Prints to terminal stdout

RenderSurface.toAnsi():
    • Half-block rendering: 2 vertical pixels per character
    • Uses ▀ (upper half block) and ▄ (lower half block)
    • Generates RGB ANSI codes: \x1b[38;2;r;g;bm (FG), \x1b[48;2;r;g;bm (BG)
    • Achieves double vertical resolution in terminal


RENDERING MODES:
================

Screen.screen_mode:
    • .transparent: Transparent background (clearTransparent)
    • .bgcolor: Solid background color (clearColored)

Set via: screen.setScreenMode(.transparent)


COORDINATE SYSTEM:
==================

Position (x, y):
    • x: horizontal position (characters)
    • y: vertical position (pixel rows, not character rows)
    • Supports negative values (off-screen clipping)

Z-order (z):
    • Higher z-values render on top
    • Default: 0
    • RenderEngine respects z when merging

Dimensions (w, h):
    • w: width in characters/pixels
    • h: height in pixel rows (2 pixels per terminal line)
